from collections import deque
from time import sleep


###############################################
# Конкурентное выполнение двух бесконечных генераторов с помощью концепции round robin (карусель)
#
# Каждый из генераторов бесконечный, но нам надо что б они по очереди принтили знак.
# Для этого мы создаем функцию которая по очереди берет по элементы из каждого, меняя их местами
#
###############################################


def gen1():
    # бесконечная генерация чисел
    i = 0
    while True:
        yield i
        i += 1


def gen2():
    # бесконечная генерация букв "a", "b", "c"
    abc = ["a", "b", "c"]
    i = 0
    while True:
        yield abc[i % 3]
        i += 1


def round_robin(tasks: list):
    # делаем из списка генераторов очередь что б получить быстрый popleft()
    tasks_q = deque(tasks)

    # пока очередь не пуста. Генераторы (если они не бесконечные) будут опустошаться и уходить из очереди
    while tasks_q:
        # забираем нулевой генератор из очереди. Нулевым становится следующий за ним генератор
        task = tasks_q.popleft()

        try:
            # получаем следующее значение
            ch = next(task)
            print(ch)
            # спим для наглядности
            sleep(1)

            # Ставим этот генератор в конец очереди.
            # Этим мы позволяем отдать элемент на следующем круге генеатору который стоял за этим в очереди
            tasks_q.append(task)

        except StopIteration:
            # если генератор кончился то на этом шаге мы НЕ добавляем его в конец очереди
            pass


if __name__ == "__main__":
    g1 = gen1()
    g2 = gen2()

    round_robin([g1, g2])
